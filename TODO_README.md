在Android端怎么实现一套耗时检测的功能，其实现有的方案基本都本挖掘的差不多了，
在主线程上(所有线程都可以)，Looper有个成员变量Printer，我们可以通过对他的设置，来判断主线程上的情况，当然该方案一般不推荐带到线上，想带到线上呢，我们可使用插桩对Handle做全局替换，走入我们自己的代理Handle在消息执行的前后做耗时判断，Handle#post同理，另外如何统计Message的执行消耗，我们可以欣赏一下字节的这篇文章[西瓜卡顿 & ANR 优化治理及监控体系建设](https://juejin.cn/post/6997227972973461512)，其实native也有对应的Looper我们可以hook对应的方法，统计c++端对主线程的消耗，最大的不足是判断不到具体的方法，到底是走到哪里出的问题？    
- SystemTrace，开发过程中常用的性能检测工具     
- 还有就是老生常谈的方法插桩。

### 方法插桩存在的问题
方法插桩检测耗时就是在方法的入口出口设置上对应的插桩代码，从而实现了该方法运行耗时统计，一般我们会把该方法描述信息，插桩到所有的方法里，就可以很清晰的看到耗时链路了。
到这里就出现了三个问题，包体积增大、性能下降、对代码混淆能力的破坏

- 包体积增大：我们对每个方法都插入了对应的代码，方法字符串肯定会增加包大小，简单的处理，可以对set，get方法相关的赋值操作过滤，空构造函数过滤，等。
- 性能下降：字符串的插入，其创建销毁的时间消耗，耗时计算的消耗，海量方法插桩，慢慢的性能也就跟着下降了。
- 对代码混淆能力的破坏：插桩带入了方法名描述，自然使该方法的混淆失去了作用。

### 1.应对代码混淆能力的破坏
关于这点，其实也很简单，这里可以参考腾讯的Matix，插桩的时候使用数字代替方法描述，也就是把方法名称参数描述和数字做成一个映射（2->show(LObject;IJ)V），这样被人逆向的话，只能看到对应的数字，同时数字作为基本类型，没有对象的创建销毁，也提升了性能，另外这一步也降低包体积的增量。

### 2.应对性能下降
1的实现，其实性能优化上有了很大的提升了，更进一步的话，我们可以把插桩执行的顺序放到混淆之后，混淆后代码会做一下优化，会减少一些方法数，比如set、get可能被剔除。我们插桩实现覆盖了几乎所有的方法，其实是没有必要的，紧接着看3的实现。

### 3.应对包体积增大
1的实现，方法描述字符串被变成数字，对缩包的其实已经有了很大的效果，然后2提到我们之前是几乎对所有的方法都做了插桩，这样对于我们查问题当然很有帮助，考虑到上线，我开始的时候尝试了用注解去过滤那些我们明确知道执行效率的方法（比如一些简单的成员变量的赋值、比如glide库内部执行全部过滤等），这样的话对于新的代码我们可以这么做，然而开发过程中我们本身也可能会出现误判，同时性能检验往往都在我们app上线后才会开始关注，对历史代码的过滤就很繁琐了。
我们打印出来的调用栈可能很长，很多时候我们看到最外层对应的方法耗时，就已经能知道大体的方向，那我们可不可以这样，控制一定方法的调用深度做插桩实现，也就是线上控制插桩到对应的调用链路的开始几层，拿到数据后我们可以到线下的全量插桩上去寻找真正耗时的方法，当然有些耗时的情况，在线下我们自己很难复现，像这种问题我们可以尝试打开app端的Atrace（通常我们对它的使用是在电脑上的SystemTrace）字节最近开源了对应的实现[btrace](https://github.com/bytedance/btrace)，在插桩监控调用的最里面那一层的方法上插入对应的Trace#beginSection(String) 和 Trace#endSection()，这样我们就可以看到这个方法执行过程系统的调度。     
         
#### 实现插桩方法调用深度的控制
怎么控制插桩到方法调用栈的最外层对应的几个方法呢，在我们实现插桩的时候，MethodVisitor#visitMethod存在这个方法，我们可以知道里面调用的那些方法是被谁调用的，同理当前这个方法也会在一个visitMethod被访问到，那么我们就可以把所有的方法调用串起来，然后我们就可以知道对应的方法的调用深度，当然一个方法可能被好几个地方调用到，也就是它会出现在不同的调用链里，这里我们选一个最短的链路，来做当前节点的深度判断，到这一步，就知道哪些方法我们需要插桩，所以这里会有两个插桩的Task，第一个判断方法深度，第二才会去做插桩（当然这里也可以尝试ASM ClassNode对应的API，方法节点带上方法插桩LdcInsnNode列表，确认好方法深度后，可以直接改对应的LdcInsnNode列表，原地插桩，这样就合并到一个Task了）。       
这里再配合上注解，那些肯定不耗时的方法，我们仍然可以手动标记，如果当前节点是被标的不做插桩，如果当前节点在调用栈上其之前的链路存在多少对应标记的节点，深度判断减相应的个数.      
> tip: 以上的插桩实现因为要保存所有的方法信息，内存暂用非常大，可能需要对AS的内存配置做调整。

### 埋点上报
埋点最终上报当然使用的对应的埋点库    
对应的方法执行超过一定时间（5mm），我们要对该方法的信息上报，其中还会有这中情况一个Message的执行中包含了连续多个5mm的方法，所以只对方法执行做上报肯定是不够的，我们还要加上Message执行的判断，这里会有对应的队列（双向队列，简单分为主线程与其他子线程，结合消息执行时间，如果最开始的方法执行时间与当前超过30s，会剔除）记录方法插桩里对应的方法执行（包括进入方法时间，离开方法时间），通常只标记主线程，发生卡顿的时候，我们就可以带上方法执行队列，我们就能很清晰的知道message耗时具体在哪里。如果发生ANR，还可以用对应的队列追溯ANR前30秒在干了什么，方便定位。

> 以上实现中出现的数字，最佳数值仍需要测试

### 总结-一套高效的原生端方法耗时检测实现
处理插桩问题过程
- 插桩方法描述映射到对应的数字
- 调整插桩任务的顺序
- 控制插桩到对应的方法深度
- 配合Atrace定位顽固问题   

使用队列记录运行过程中对应插桩到的方法，帮助定位卡顿、ANR
